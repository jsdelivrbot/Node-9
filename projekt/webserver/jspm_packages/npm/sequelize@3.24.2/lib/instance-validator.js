/* */ 
(function(Buffer) {
  'use strict';
  var validator = require('./utils/validator-extras').validator,
      extendModelValidations = require('./utils/validator-extras').extendModelValidations,
      Utils = require('./utils'),
      sequelizeError = require('./errors'),
      Promise = require('./promise'),
      DataTypes = require('./data-types'),
      _ = require('lodash');
  var InstanceValidator = module.exports = function(modelInstance, options) {
    options = _.clone(options) || {};
    if (options.fields && !options.skip) {
      options.skip = Utils._.difference(Object.keys(modelInstance.Model.attributes), options.fields);
    }
    this.options = Utils._.defaults(options, {skip: []});
    this.modelInstance = modelInstance;
    this.validator = validator;
    this.errors = [];
    this.inProgress = false;
    extendModelValidations(modelInstance);
  };
  InstanceValidator.RAW_KEY_NAME = '__raw';
  InstanceValidator.prototype.validate = function() {
    if (this.inProgress) {
      throw new Error('Validations already in progress.');
    }
    this.inProgress = true;
    var self = this;
    return Promise.all([self._builtinValidators(), self._customValidators()].map(function(promise) {
      return promise.reflect();
    })).then(function() {
      if (self.errors.length) {
        return new sequelizeError.ValidationError(null, self.errors);
      } else {
        return null;
      }
    });
  };
  InstanceValidator.prototype.hookValidate = function() {
    var self = this;
    return self.modelInstance.Model.runHooks('beforeValidate', self.modelInstance, self.options).then(function() {
      return self.validate().then(function(error) {
        if (error) {
          return self.modelInstance.Model.runHooks('validationFailed', self.modelInstance, self.options, error).then(function(newError) {
            throw newError || error;
          });
        }
      });
    }).then(function() {
      return self.modelInstance.Model.runHooks('afterValidate', self.modelInstance, self.options);
    }).return(self.modelInstance);
  };
  InstanceValidator.prototype._builtinValidators = function() {
    var self = this;
    var validators = [];
    Utils._.forIn(this.modelInstance.rawAttributes, function(rawAttribute, field) {
      if (self.options.skip.indexOf(field) >= 0) {
        return;
      }
      var value = self.modelInstance.dataValues[field];
      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {
        self._validateSchema(rawAttribute, field, value);
      }
      if (self.modelInstance.validators.hasOwnProperty(field)) {
        validators.push(self._builtinAttrValidate.call(self, value, field).reflect());
      }
    });
    return Promise.all(validators);
  };
  InstanceValidator.prototype._customValidators = function() {
    var validators = [];
    var self = this;
    Utils._.each(this.modelInstance.$modelOptions.validate, function(validator, validatorType) {
      if (self.options.skip.indexOf(validatorType) >= 0) {
        return;
      }
      var valprom = self._invokeCustomValidator(validator, validatorType).catch(function() {}).reflect();
      validators.push(valprom);
    });
    return Promise.all(validators);
  };
  InstanceValidator.prototype._builtinAttrValidate = function(value, field) {
    var self = this;
    if (value === null || typeof value === 'undefined') {
      return Promise.resolve();
    }
    var validators = [];
    Utils._.forIn(this.modelInstance.validators[field], function(test, validatorType) {
      if (['isUrl', 'isURL', 'isEmail'].indexOf(validatorType) !== -1) {
        if (typeof test === 'object' && test !== null && test.msg) {
          test = {msg: test.msg};
        } else if (test === true) {
          test = {};
        }
      }
      if (typeof test === 'function') {
        return validators.push(self._invokeCustomValidator(test, validatorType, true, value, field).reflect());
      }
      var validatorPromise = self._invokeBuiltinValidator(value, test, validatorType, field);
      validatorPromise.catch(function() {});
      validators.push(validatorPromise.reflect());
    });
    return Promise.all(validators).then(this._handleReflectedResult.bind(this, field));
  };
  InstanceValidator.prototype._invokeCustomValidator = Promise.method(function(validator, validatorType, optAttrDefined, optValue, optField) {
    var validatorFunction = null;
    var isAsync = false;
    var validatorArity = validator.length;
    var asyncArity = 1;
    var errorKey = validatorType;
    var invokeArgs;
    if (optAttrDefined) {
      asyncArity = 2;
      invokeArgs = optValue;
      errorKey = optField;
    }
    if (validatorArity === asyncArity) {
      isAsync = true;
    }
    if (isAsync) {
      if (optAttrDefined) {
        validatorFunction = Promise.promisify(validator.bind(this.modelInstance, invokeArgs));
      } else {
        validatorFunction = Promise.promisify(validator.bind(this.modelInstance));
      }
      return validatorFunction().catch(this._pushError.bind(this, false, errorKey));
    } else {
      return Promise.try(validator.bind(this.modelInstance, invokeArgs)).catch(this._pushError.bind(this, false, errorKey));
    }
  });
  InstanceValidator.prototype._invokeBuiltinValidator = Promise.method(function(value, test, validatorType, field) {
    var self = this;
    var valueString = String(value);
    if (typeof validator[validatorType] !== 'function') {
      throw new Error('Invalid validator function: ' + validatorType);
    }
    var validatorArgs = self._extractValidatorArgs(test, validatorType, field);
    if (!validator[validatorType].apply(validator, [valueString].concat(validatorArgs))) {
      throw new Error(test.msg || 'Validation ' + validatorType + ' failed');
    }
  });
  InstanceValidator.prototype._extractValidatorArgs = function(test, validatorType, field) {
    var validatorArgs = test.args || test;
    var isLocalizedValidator = typeof(validatorArgs) !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');
    if (!Array.isArray(validatorArgs)) {
      if (validatorType === 'isImmutable') {
        validatorArgs = [validatorArgs, field];
      } else if (isLocalizedValidator || validatorType === 'isIP') {
        validatorArgs = [];
      } else {
        validatorArgs = [validatorArgs];
      }
    } else {
      validatorArgs = validatorArgs.slice(0);
    }
    return validatorArgs;
  };
  InstanceValidator.prototype._validateSchema = function(rawAttribute, field, value) {
    var error;
    if (rawAttribute.allowNull === false && ((value === null) || (value === undefined))) {
      error = new sequelizeError.ValidationErrorItem(field + ' cannot be null', 'notNull Violation', field, value);
      this.errors.push(error);
    }
    if (rawAttribute.type === DataTypes.STRING || rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type === DataTypes.TEXT || rawAttribute.type instanceof DataTypes.TEXT) {
      if (Array.isArray(value) || (_.isObject(value) && !value._isSequelizeMethod) && !Buffer.isBuffer(value)) {
        error = new sequelizeError.ValidationErrorItem(field + ' cannot be an array or an object', 'string violation', field, value);
        this.errors.push(error);
      }
    }
  };
  InstanceValidator.prototype._handleReflectedResult = function(field, promiseInspections) {
    var self = this;
    promiseInspections.forEach(function(promiseInspection) {
      if (promiseInspection.isRejected()) {
        var rejection = promiseInspection.error();
        self._pushError(true, field, rejection);
      }
    });
  };
  InstanceValidator.prototype._pushError = function(isBuiltin, errorKey, rawError) {
    var message = rawError.message || rawError || 'Validation error';
    var error = new sequelizeError.ValidationErrorItem(message, 'Validation error', errorKey, rawError);
    error[InstanceValidator.RAW_KEY_NAME] = rawError;
    this.errors.push(error);
  };
})(require('buffer').Buffer);
